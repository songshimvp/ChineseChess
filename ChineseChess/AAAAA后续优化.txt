后续优化0：画“炮”、“兵”的特殊位置标记；√√√√√
后续优化00：在人机对战中，人点击以后，为了不让电脑思考阻塞主进程以及时刷新屏幕，优化电脑思考等待时间！


后续优化1：给所有的可能的走法排个序；――――SingleGame.cpp，53行
        提醒：原先电脑总是喜欢走兵。但是事实上车、马、炮走的多一些！

后续优化2：此处使用的是静态局面分，另外此处的局面分是按照自认为的棋子类型的重要性进行划分的；――――SingleGame.cpp，138行
        提醒：比如：“兵”！“兵”过河以后相当于半个“车”，显然这种静态的局面分不合规矩！
	    
后续优化3：数据结构的松散，便于理解，但是导致程序运行效率的降低；――――Stone.h，12行

后续优化4：各类型棋子的canMove()函数会被调用很多次；――――Board.h，70行
        后续优化4提醒：对于各类型不同的棋子不需要遍历整个棋盘。比如：兵，只需要判断周围一圈就可以			

后续优化5：没有判断输赢――；
        “将”死！
后续优化6：中英文功能（选择对话框、悔棋）

后续优化7：设置开始按钮，空白棋盘――――（1）棋子摆定！（2）重新开始游戏；

后续优化8：鼠标点击事件；――――Board.cpp，260行，和 视频02，Board.cpp，214行

后续优化9：将pt转化成象棋的行列值――下述方法效率不高――循环判断鼠标点击的位置和棋子中心的距离；Board.cpp，250行
         后续优化9提醒：除一除？？？？？？？
		 
后续优化10：记录取胜的步骤数！（最好是能记录时间，步骤数，以便人工智能破纪录的记录）
          全局变量。

后续优化11：显示音效、显示下一手棋子颜色；
          参考C#五子棋游戏代码
		  
后续优化12：设置棋盘背景、ctrl背景；

后续优化13：宏定义函数块可以加快程序的执行速度（牺牲空间换时间）；	

后续优化14：将、将照面直接吃。电脑却不能做出这步判断！

后续优化15：在现有基础上，调试_level，测试在用户能接受的时间范围内_level 的最大值；

后续优化16：网络对战版的“悔棋”操作待优化！或者是有点小BUG。当甲吃掉乙的棋子时，肯定是乙要求悔棋，
            乙去执行“悔棋”操作（程序已经做到）；但是比如当甲走棋，发现自己走错了，想换个走法，就需要甲去执行“悔棋操作”，
			程序不能做到这一点。
		提示：（1）添加聊天窗口，进行沟通（既符合现实，也容易实现）；（2）增加按钮（方案不好）；	
